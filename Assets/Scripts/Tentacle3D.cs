using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using SplineMesh;

[ExecuteInEditMode]
public class Tentacle3D : MonoBehaviour
{
    public Transform targetDir;

private bool toUpdate = false;
    private GameObject generated;
    private GameObject Generated {
        get {
            if (generated == null) {
                string generatedName = "generated by " + GetType().Name;
                var generatedTranform = transform.Find(generatedName);
                generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);
            }
            return generated;
        }
    }

    private Spline spline;
    private GameObject firstSegment;

    [SerializeField]
    public List<GameObject> wayPoints = new List<GameObject>();

    public GameObject prefabWaypoint;
    public int segmentCount;
    public float segmentSpacing;

    private void OnEnable() {
        spline = GetComponent<Spline>();
        toUpdate = true;
    }

    private void OnValidate() {
        toUpdate = true;
    }

    private void Update() {
        if (toUpdate) {
            toUpdate = false;
            Generate();
            UpdateSpline();
        }
        UpdateNodes();

        // balancing
        // if (Application.isPlaying) {
        //     firstSegment.transform.localPosition = new Vector3(Mathf.Sin(Time.time) * 3, 0, 0);
        // }
    }

    private void UpdateNodes() {
        int i = 0;
        foreach (GameObject wayPoint in wayPoints) {
            var node = spline.nodes[i++];
            if (Vector3.Distance(node.Position, transform.InverseTransformPoint(wayPoint.transform.position)) > 0.001f) {
                node.Position = transform.InverseTransformPoint(wayPoint.transform.position);
                Debug.Log(node.Position);
                // node.Direction = node.Position + wayPoint.transform.forward * -1f;
                Debug.Log(node.Direction);
                node.Up = wayPoint.transform.right;
            }
        }
    }

    private void UpdateSpline() {
        foreach (var penisNode in wayPoints.ToList()) {
            if (penisNode == null) wayPoints.Remove(penisNode);
        }
        int nodeCount = wayPoints.Count;
        // adjust the number of nodes in the spline.
        while (spline.nodes.Count < nodeCount) {
            spline.AddNode(new SplineNode(Vector3.zero, Vector3.zero));
        }
        while (spline.nodes.Count > nodeCount && spline.nodes.Count > 2) {
            spline.RemoveNode(spline.nodes.Last());
        }
    }

    private void Generate() {
        UOUtility.DestroyChildren(Generated);
        wayPoints.Clear();

        float localSpacing = 0;
        for (int i = 0; i < segmentCount; i++) {
            var seg = UOUtility.Instantiate(prefabWaypoint, Generated.transform);
            seg.transform.Translate(0, 0, -localSpacing);

            // we fix the first segment so that the rope won't fall
            if (i == 0) {
                firstSegment = seg;
            }

            // we save segments as way points for the spline deformation.
            wayPoints.Add(seg);
            localSpacing += segmentSpacing;
        }
    }
    // public Transform targetDir;
    // public float length;
    // [Min(2f)]
    // public int resolution;
    // public float smoothSpeed;
    // public float trailSpeed;
    // private float dist;
    // private Spline spline;
    // private Vector3[] segmentV;

    // // Start is called before the first frame update
    // void Start()
    // {
    //     spline = GetComponentInChildren<Spline>();
    //     dist = length / resolution; 
    //     segmentV = new Vector3[resolution];
    //     initSpline();
    // }

    // // Update is called once per frame
    // void Update()
    // {
    //     // spline.AddNode();
    //     spline.nodes[0].SetPosDir(targetDir.localPosition, targetDir.localPosition + targetDir.right * dist);

    //     for(int i = 1; i < resolution; i++) {
    //         SplineNode sn = spline.nodes[i];
    //         Vector3 targetPos = spline.nodes[i - 1].Position + targetDir.right * dist;
    //         // Vector3 targetPos = segmentPoses[i - 1] + (segmentPoses[i] - segmentPoses[i - 1]).normalized * dist;

    //         spline.RemoveNode(sn);
    //         spline.AddNode(new SplineNode(Vector3.SmoothDamp(spline.nodes[i].Position, targetPos, ref segmentV[i], smoothSpeed + i / trailSpeed),
    //                                         targetPos + targetDir.right * dist));
    //     }
    // }

    // private void initSpline() {
    //     spline.nodes[0].SetPosDir(targetDir.localPosition, targetDir.localPosition + targetDir.right * dist);
    //     for(int i = 1; i < resolution; i++) {
    //         Vector3 targetPos = spline.nodes[i - 1].Position + targetDir.right * dist;
    //         spline.InsertNode(i, new SplineNode(targetPos, targetPos + ((targetDir.right * dist) / 2)));
    //     }

    //     // spline.RemoveNode(spline.nodes[resolution - 1]);
    // }
}
